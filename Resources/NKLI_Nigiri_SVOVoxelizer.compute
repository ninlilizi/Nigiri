/// <summary>
/// NKLI     : Nigiri - SVO Voxelization COMPUTE
/// Copywrite: Abigail Sara Hocking of Newbury, 2020. 
/// Licence  : The Nigiri 'Bits and pieces' Licence. [v3]
/// </summary>
#pragma kernel CSMain

// Include
#include "NKLI_Nigiri_SVOVoxelizer_Functions.cginc"
#include "NKLI_Nigiri_MortonOrder2D.cginc"

// List of ordered pixels to sample
uniform ConsumeStructuredBuffer<uint> _maskBuffer;

// SVO
uniform RWStructuredBuffer<SVONode> _SVO;
// SVO Counters
uniform RWStructuredBuffer<uint> _SVO_Counters;
// SVO Queue of nodes to split
uniform RWStructuredBuffer<uint> _SVO_SplitQueue;

// Max SVO depth
uniform const uint _maxDepth;

// Sample inputs
uniform const float _emissiveIntensity;
uniform const float _shadowStrength;
uniform const float _occlusionGain;
uniform const float _giAreaSize;

// Sample input textures
uniform Texture2D<float4> positionTexture;
uniform Texture2D<float4> lightingTexture;
uniform Texture2D<float4> lightingTexture2;
uniform Texture2D _CameraDepthTexture;

// Groupshared array of node split offsets
groupshared uint MaxTTL = 0;
groupshared uint MinOffset = 0;

/// <summary>
/// Encodes samples into tree
/// </summary>
[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
    // Get mask position
    //uint counter;
    //InterlockedAdd(_SVO_Counters[4], 1, counter);
    
    // Get morton ordered read index from mask buffer
    uint2 orderedCoord = morton2D_MagicBits_Decode(_maskBuffer.Consume());
    //uint2 orderedCoord = morton2D_MagicBits_Decode(_maskBuffer[counter]);
    //uint2 orderedCoord = oneD2twoD(counter, 1920);
    
    float4 colour = GetNewMixedColour(orderedCoord, lightingTexture, lightingTexture2, _emissiveIntensity, _shadowStrength, _occlusionGain);
    float depth = _CameraDepthTexture[orderedCoord].r;
   
    // Traverse the SVO, splitting and writing the sampled colour as required
    SplitRequest split = SplitInsertSVO(
        _SVO, _SVO_SplitQueue, _SVO_Counters, (positionTexture[orderedCoord]),
        colour, depth,
        _giAreaSize);
    
   
    // Find highest TTL
    InterlockedMax(MaxTTL, split.TTL);
    
    // If highest TTL
    if (split.TTL == MaxTTL)
    {
        // Find highest offet
        InterlockedMax(MinOffset, split.offset);
        
    }

    // Syncronise threads
    GroupMemoryBarrierWithGroupSync();
    
    // If thread zero and MinOffet is non-zero. Append offset to split queue
    if ((thread == 0) && MinOffset != 0)
        AppendSVOSplitQueue(_SVO_SplitQueue, _SVO_Counters, MinOffset);;
}