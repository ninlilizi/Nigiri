/// <summary>
/// NKLI     : Nigiri - SVO Voxelization COMPUTE
/// Copywrite: Abigail Sara Hocking of Newbury, 2020. 
/// Licence  : The Nigiri 'Bits and pieces' Licence. [v3]
/// </summary>
#pragma kernel CSMain

// Include
#include "NKLI_Nigiri_SVOVoxelizer_Functions.cginc"
#include "NKLI_Nigiri_MortonOrder2D.cginc"

// List of ordered pixels to sample
uniform RWStructuredBuffer<uint> _maskBuffer;

// SVO
uniform RWStructuredBuffer<SVONode> _SVO;
// SVO Counters
uniform RWStructuredBuffer<uint> _SVO_Counters;
// SVO Queue of nodes to split
uniform RWStructuredBuffer<uint> _SVO_SplitQueue;
// SVO Queue of nodes to mipmap
uniform RWStructuredBuffer<uint> _SVO_MipmapQueue;

// Max SVO depth
uniform const uint _maxDepth;

// Sample inputs
uniform const float _emissiveIntensity;
uniform const float _shadowStrength;
uniform const float _occlusionGain;
uniform const float _giAreaSize;

// Sample input textures
uniform Texture2D<float4> positionTexture;
uniform Texture2D<float4> lightingTexture;
uniform Texture2D<float4> lightingTexture2;
uniform Texture2D _CameraDepthTexture;

// Groupshared array of node split offsets
groupshared uint split_MaxTTL = 0;
groupshared uint split_MinOffset = 0;
groupshared uint mipmap_MaxTTL = 0;
groupshared uint mipmap_MinOffset = 0;

/// <summary>
/// Encodes samples into tree
/// </summary>
[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
    // Get mask position
    uint counter;
    InterlockedAdd(_SVO_Counters[5], 1, counter);
    
    // Get morton ordered read index from mask buffer
    uint2 orderedCoord = morton2D_MagicBits_Decode(_maskBuffer[counter]);
    
    float4 colour = GetNewMixedColour(orderedCoord, lightingTexture, lightingTexture2, _emissiveIntensity, _shadowStrength, _occlusionGain);
    float depth = _CameraDepthTexture[orderedCoord].r;
   
    // Traverse the SVO, splitting and writing the sampled colour as required
    TraversalResult traversalResult = SplitInsertSVO(
        _SVO, _SVO_SplitQueue, _SVO_MipmapQueue, _SVO_Counters, (positionTexture[orderedCoord]),
        colour, depth,
        _giAreaSize);
    
    // Calculate priority split offset
    InterlockedMax(split_MaxTTL, traversalResult.TTL);
    if (traversalResult.TTL == split_MaxTTL)
    {
        InterlockedMax(split_MinOffset, traversalResult.offset);
    }
    
    // Syncronise threads
    GroupMemoryBarrierWithGroupSync();
    
    // If thread zero and MinOffet is non-zero. Append offset to split queue
    if ((thread == 0))
    {
        if (split_MinOffset != 0)
            AppendSVOSplitQueue(_SVO_SplitQueue, _SVO_Counters, split_MinOffset);
    }
}