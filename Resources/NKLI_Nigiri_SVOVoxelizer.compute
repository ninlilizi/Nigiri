/// <summary>
/// NKLI     : Nigiri - SVO Voxelization COMPUTE
/// Copywrite: Abigail Sara Hocking of Newbury, 2020. 
/// Licence  : The Nigiri 'Bits and pieces' Licence. [v3]
/// </summary>
#pragma kernel CSMain

// Include
#include "NKLI_Nigiri_SVOVoxelizer_Functions.cginc"
#include "NKLI_Nigiri_MortonOrder2D.cginc"

// List of ordered pixels to sample
uniform RWStructuredBuffer<uint> _maskBuffer;

// SVO
uniform RWStructuredBuffer<SVONode> _SVO;
// SVO Counters
uniform RWStructuredBuffer<uint> _SVO_Counters;
// SVO Queue of nodes to split
uniform RWStructuredBuffer<uint> _SVO_SplitQueue;
// SVO Queue of nodes to mipmap
uniform RWStructuredBuffer<uint> _SVO_MipmapQueue;

// Max SVO depth
uniform const uint _maxDepth;

// Is it safe to add to the mip queue?
uniform const int _mipmapQueueEmpty;

// Sample inputs
uniform const float _emissiveIntensity;
uniform const float _shadowStrength;
uniform const float _occlusionGain;
uniform const float _giAreaSize;

// Sample input textures
uniform Texture2D<float4> positionTexture;
uniform Texture2D<float4> lightingTexture;
uniform Texture2D<float4> lightingTexture2;
uniform Texture2D _CameraDepthTexture;

// Groupshared array of node split offsets
groupshared uint mip_MinTTL = 16;
groupshared uint split_MaxTTL = 0;
groupshared uint mip_MinOffset = 4294967295;
groupshared uint split_MinOffset = 4294967295;


/// <summary>
/// Encodes samples into tree
/// </summary>
[numthreads(1024, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
    // Get mask position
    uint counter;
    InterlockedAdd(_SVO_Counters[5], 1, counter);
    
    // Get morton ordered read index from mask buffer
    uint2 orderedCoord = morton2D_MagicBits_Decode(_maskBuffer[counter]);
    
    float4 colour = GetNewMixedColour(orderedCoord, lightingTexture, lightingTexture2, _emissiveIntensity, _shadowStrength, _occlusionGain);
    float depth = _CameraDepthTexture[orderedCoord].r;
   
    // Traverse the SVO, splitting and writing the sampled colour as required
    TraversalResult traversalResult = TraverseSVO(
        _SVO, _SVO_SplitQueue, _SVO_MipmapQueue, _SVO_Counters, (positionTexture[orderedCoord]),
        colour, depth, _giAreaSize, _mipmapQueueEmpty);

    // 1 = Split, 2 = Mipmap
    switch (traversalResult.action)
    {
        case 1:
            // Calculate priority split offset
            InterlockedMax(split_MaxTTL, traversalResult.TTL);
            if (traversalResult.TTL == split_MaxTTL)
            {
                InterlockedMin(split_MinOffset, traversalResult.offset);
            }
            break;
        case 2:
            // Calculate priority mipmap offset
            InterlockedMin(mip_MinTTL, traversalResult.TTL);
            if (traversalResult.TTL == mip_MinTTL)
            {
                InterlockedMin(mip_MinOffset, traversalResult.offset);
            }
            break;
    }
    
    // Syncronise threads
    GroupMemoryBarrierWithGroupSync();
    
    // We only do this on thread zero of the group
    if (!thread)
    {
        // Write out chosen nodes, to be picked up by the cpu worker threads
        if (split_MinOffset)
        {
            AppendSVOSplitQueue(_SVO_SplitQueue, _SVO_Counters, split_MinOffset);
            _SVO[split_MinOffset - 1] = SetNodeColour(_SVO[split_MinOffset - 1], colour / 4, depth);
        }
        if (mip_MinOffset)
        {
            AppendSVOMipmapQueue(_SVO_MipmapQueue, _SVO_Counters, mip_MinOffset);
            _SVO[mip_MinOffset - 1].SetIsWaitingForMipmap(0);
        }
        
    }
}