/// <summary>
/// NKLI     : Nigiri - SVO Voxelization COMPUTE
/// Copywrite: Abigail Sara Hocking of Newbury, 2020. 
/// Licence  : The Nigiri 'Bits and pieces' Licence. [v3]
/// </summary>
#pragma kernel CSMain

// Include
#include "NKLI_Nigiri_SVOVoxelizer_Functions.cginc"
#include "NKLI_Nigiri_MortonOrder2D.cginc"

// List of ordered pixels to sample
uniform ConsumeStructuredBuffer<uint> _maskBuffer;

// SVO
uniform RWStructuredBuffer<SVONode> _SVO;
// SVO Counters
uniform RWStructuredBuffer<uint> _SVO_Counters;
// SVO Queue of nodes to split
uniform RWStructuredBuffer<uint> _SVO_SplitQueue;

// Max SVO depth
uniform const uint _maxDepth;

// Sample inputs
uniform const float _emissiveIntensity;
uniform const float _shadowStrength;
uniform const float _occlusionGain;
uniform const float _giAreaSize;

// Sample input textures
uniform Texture2D<float4> positionTexture;
uniform Texture2D<float4> lightingTexture;
uniform Texture2D<float4> lightingTexture2;
uniform Texture2D _CameraDepthTexture;

// Groupshared array of node split offsets
//groupshared uint splitOffsets[96];
groupshared SplitRequest splits[64];
groupshared uint ableToSplit = 0;

/// <summary>
/// Encodes samples into tree
/// </summary>
[numthreads(64, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
    // Get mask position
    //uint counter;
    //InterlockedAdd(_SVO_Counters[4], 1, counter);
    
    // Get morton ordered read index from mask buffer
    uint2 orderedCoord = morton2D_MagicBits_Decode(_maskBuffer.Consume());
    //uint2 orderedCoord = morton2D_MagicBits_Decode(_maskBuffer[counter]);
    //uint2 orderedCoord = oneD2twoD(counter, 1920);
    
    float4 colour = GetNewMixedColour(orderedCoord, lightingTexture, lightingTexture2, _emissiveIntensity, _shadowStrength, _occlusionGain);
    float depth = _CameraDepthTexture[orderedCoord].r;
   
    // Traverse the SVO, splitting and writing the sampled colour as required
    splits[thread] = SplitInsertSVO(
        _SVO, _SVO_SplitQueue, _SVO_Counters, (positionTexture[orderedCoord]),
        colour, depth,
        _giAreaSize);
    
    //if (split.TTL > highestTTL)
    //{
     //   highestTTL = split.TTL;
    //
    //}
       
    // Only append to split queue if non-zero offset returned
    if (splits[thread].offset != 0)
        ableToSplit = 1;
    
    // Syncronise threads
    GroupMemoryBarrierWithGroupSync();
    
    // Append upto 8 nodes to the split queue after checking for dupes
    if ((thread == 0) && (ableToSplit == 1))
        DeDupeAppendSplitQueue(thread, splits, _SVO_SplitQueue, _SVO_Counters);

}