#pragma kernel CSMain0
#include "Nigiri_MortonOrder3D.cginc"
#include "NKLI_Nigiri_SVONode.cginc"

RWTexture3D<float4> voxelGrid;

// Unique Index for computing access coordinates
uniform RWStructuredBuffer<uint>	_renderCountBuffer;
// Output samples from voxelizer
uniform RWStructuredBuffer<uint4>	_sampleBuffer;
// Output sample counts from voxelizer
uniform RWStructuredBuffer<uint>	_sampleCountBuffer;
// SVO Counters
uniform RWStructuredBuffer<uint> _SVO_Counters;
// SVO Queue of nodes to split
uniform RWStructuredBuffer<uint> _SVO_SplitQueue;
// SVO
uniform RWStructuredBuffer<SVONode> _SVO;


cbuffer cbSettings : register(b0)
{
	uniform const uint				CountIndex;
};

// 0 - Masks alpha
[numthreads(8, 8, 8)]
void CSMain0(uint3 id : SV_DispatchThreadID)
{
	// Update Unique index
	uint counter;
	InterlockedAdd(_renderCountBuffer[CountIndex], 1, counter);

	// Get Morton coordinate
	uint3 index3D = morton3D_Magicbits_Decode(counter);

	uint output;
	float4 newColour = _sampleBuffer[counter];

	if (_sampleCountBuffer[counter] > 0)
	{
		voxelGrid[index3D] = newColour / (_sampleCountBuffer[counter]) / 255;
		InterlockedExchange(_sampleCountBuffer[counter], 0, output);
		InterlockedExchange(_sampleBuffer[counter].r, 0, output);
		InterlockedExchange(_sampleBuffer[counter].g, 0, output);
		InterlockedExchange(_sampleBuffer[counter].b, 0, output);
		InterlockedExchange(_sampleBuffer[counter].a, 0, output);

		// Update Occupied voxel Count
		uint occupiedCounter;
		InterlockedAdd(_renderCountBuffer[6], 1, occupiedCounter);
        
        //
        // Traverse tree
        uint maxWidth = 256;
        uint maxDepth = _SVO_Counters[0];
        uint currentDepth = 0;
        uint currentWidth = 1;
        uint done = 0;
        uint offset = 0;
        while (done != 1)
        {
            SVONode node = _SVO[offset];
            uint bitfieldOccupancy;
            uint runLength;
            uint depth;
            uint isLeaf;
            node.UnPackStruct(bitfieldOccupancy, runLength, depth, isLeaf);
            
            if (currentDepth = maxDepth)
            {
                node.value_R = newColour.r;
                node.value_G = newColour.g;
                node.value_B = newColour.b;
                node.value_A = newColour.a;
                
                _SVO[offset] = node;
                
                done = 1;
            }
            else
            {
            
                if (bitfieldOccupancy != 0)
                {
                    currentDepth++;
                
                    uint nextIndex = 0;
                               
                    uint halfWidth = maxWidth / (currentDepth * 2);
                    if (index3D.x > halfWidth)
                        nextIndex = nextIndex | (1);
                    if (index3D.y > halfWidth)
                        nextIndex = nextIndex | (1 << 1);
                    if (index3D.z > halfWidth)
                        nextIndex = nextIndex | (1 << 2);

                    offset = nextIndex;
                }
                else
                {
                // Update Unique index
                    uint counter_SplitQueue;
                    InterlockedAdd(_SVO_Counters[2], 1, counter_SplitQueue);
                
                    if (counter_SplitQueue < _SVO_Counters[1])
                    {
                        _SVO_SplitQueue[counter_SplitQueue] = offset;
                    }
                
                    done = 1;
                }
            }
        }
        //
        //
	}
	else// if (SampleCountBuffer[counter].y > 0)
	{
		// Decay currently visible, but empty voxels.
		//InterlockedExchange(SampleCountBuffer[counter], 0, output);
		voxelGrid[index3D] *= 0.25;

		// Consider updating Occupied voxel Count
		if ((voxelGrid[index3D].r > 0.1) ||
			(voxelGrid[index3D].g > 0.1) ||
			(voxelGrid[index3D].b > 0.1) ||
			(voxelGrid[index3D].a > 0.1))
		{
			uint occupiedCounter;  InterlockedAdd(_renderCountBuffer[6], 1, occupiedCounter);
		}
	}	
}
