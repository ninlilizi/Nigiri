#pragma kernel CSMain0
#include "Nigiri_MortonOrder3D.cginc"

RWTexture3D<float4> voxelGrid;

// Unique Index for computing access coordinates
uniform RWStructuredBuffer<uint>	_renderCountBuffer;
// Output samples from voxelizer
uniform RWStructuredBuffer<uint4>	_sampleBuffer;
// Output sample counts from voxelizer
uniform RWStructuredBuffer<uint>	_sampleCountBuffer;

cbuffer cbSettings : register(b0)
{
	uniform const uint				CountIndex;
};

// 0 - Masks alpha
[numthreads(8, 8, 8)]
void CSMain0(uint3 id : SV_DispatchThreadID)
{
	// Update Unique index
	uint counter;
	InterlockedAdd(_renderCountBuffer[CountIndex], 1, counter);

	// Get Morton coordinate
	uint3 index3D = morton3D_Magicbits_Decode(counter);

	uint output;
	float4 newColour = _sampleBuffer[counter];

	if (_sampleCountBuffer[counter] > 0)
	{
		voxelGrid[index3D] = newColour / (_sampleCountBuffer[counter]) / 255;
		InterlockedExchange(_sampleCountBuffer[counter], 0, output);
		InterlockedExchange(_sampleBuffer[counter].r, 0, output);
		InterlockedExchange(_sampleBuffer[counter].g, 0, output);
		InterlockedExchange(_sampleBuffer[counter].b, 0, output);
		InterlockedExchange(_sampleBuffer[counter].a, 0, output);

		// Update Occupied voxel Count
		uint occupiedCounter;
		InterlockedAdd(_renderCountBuffer[6], 1, occupiedCounter);
	}
	else// if (SampleCountBuffer[counter].y > 0)
	{
		// Decay currently visible, but empty voxels.
		//InterlockedExchange(SampleCountBuffer[counter], 0, output);
		voxelGrid[index3D] *= 0.25;

		// Consider updating Occupied voxel Count
		if ((voxelGrid[index3D].r > 0.1) ||
			(voxelGrid[index3D].g > 0.1) ||
			(voxelGrid[index3D].b > 0.1) ||
			(voxelGrid[index3D].a > 0.1))
		{
			uint occupiedCounter;  InterlockedAdd(_renderCountBuffer[6], 1, occupiedCounter);
		}
	}	
}
