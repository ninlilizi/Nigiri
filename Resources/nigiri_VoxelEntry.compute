// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "NKLI_Nigiri_MortonOrder2D.cginc"
#include "NKLI_Nigiri_MortonOrder3D.cginc"

uniform RWTexture3D<float4>			voxelGrid : register(u1);

//RWStructuredBuffer<int>					RenderCounter;
uniform ConsumeStructuredBuffer<uint>	_maskBufferAC;
uniform RWStructuredBuffer<uint4>		_sampleBuffer	: register(u2);
uniform RWStructuredBuffer<uint>		_sampleCountBuffer : register(u3);

cbuffer cbSettings : register(b0)
{
uniform uint							_cascade;
	uniform const uint					nearestNeighbourPropagation;
	uniform const uint					_voxelResolution;
	uniform const float3				gridOffset;
	uniform const float					_giAreaSize;
	uniform const float					_occlusionGain;
	uniform const float					_shadowStrength;
	uniform const float					_emissiveIntensity;
	
	uniform Texture2D<float4>			lightingTexture;
	uniform Texture2D<float4>			lightingTexture2;

	uniform Texture2D<float4>			positionTexture;

	uniform const float3				offsets[16] =
	{
		float3(1, 0, 0),
		float3(-1, 0, -0),
		float3(0, 1, 0),
		float3(0, -1, 0),
		float3(0, 0, 1),
		float3(0, 0, -1),
		float3(1, 1, 0),
		float3(1, -1, -0),
		float3(-1, 1, 0),
		float3(-1, -1, -0),
		float3(1, 0, 1),
		float3(1, 0, -1),
		float3(0, 1, 1),
		float3(0, 1, -1),
		float3(0, -1, 1),
		float3(0, -1, -1)
	};
};



// Function to get position of voxel in the grid
inline uint3 GetVoxelPosition(float3 worldPosition)
{
    worldPosition.xyz = worldPosition.xyz - gridOffset.xyz;
    
    float3 encodedPosition = worldPosition / _giAreaSize;
    encodedPosition += float3(1.0f, 1.0f, 1.0f);
    encodedPosition /= 2.0f;
    uint3 voxelPosition = (uint3) (encodedPosition * _voxelResolution);
    return voxelPosition;
}

uint threeD2oneD(float3 coord)
{
	return coord.z * (_voxelResolution * _voxelResolution) + (coord.y * _voxelResolution) + coord.x;
}

inline uint twoD2oneD(uint x, uint y, uint width)
{
	return x + (y * width);
}

inline uint2 oneD2twoD(uint index, uint width)
{
	return uint2(index % width, index / width);
}

// 0
[numthreads(16, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
	uint2 orderedCoord = morton2D_MagicBits_Decode(_maskBufferAC.Consume());


	//uint2 orderedCoord = id.xy;

	if ((orderedCoord.x > 0) || (orderedCoord.y > 0))
    {

        uint3 voxelPosition = GetVoxelPosition(positionTexture[orderedCoord].xyz);

        uint samplecountIndex = morton3D_Magicbits_Encode(voxelPosition.x, voxelPosition.y, voxelPosition.z);

        uint voxelUpdated = 0;

        voxelUpdated = 1;
			//uint index = threeD2oneD(voxelPosition.xyz);
			//uint cascadeBoundary0 = _voxelResolution * 0.25;
			//uint cascadeBoundary1 = _voxelResolution * 0.66;

        float4 newMixedColor = (0).xxxx;
        if (nearestNeighbourPropagation == 1)
        {
            uint count = 1;
            float4 mixedColor = voxelGrid[voxelPosition.xyz];

            for (int x = 0; x < 16; x++)
            {
                float3 offset = offsets[x];
                half4 testColor = voxelGrid[float3(voxelPosition.xyz + offset.xyz)];
                if (testColor.a > 0.1)
                {
                    mixedColor += testColor;
                    count++;
                }
            }
            mixedColor /= count;

            newMixedColor =
					float4((max(lightingTexture[orderedCoord].rgb * _emissiveIntensity, lightingTexture2[orderedCoord].rgb * (1 - _shadowStrength).xxx)),
						lightingTexture2[orderedCoord].a * _occlusionGain);

            newMixedColor = lerp(newMixedColor, mixedColor, 0.5);
        }
        else
        {
            newMixedColor =
					float4((max(lightingTexture[orderedCoord].rgb * _emissiveIntensity, lightingTexture2[orderedCoord].rgb * (1 - _shadowStrength).xxx)),
						lightingTexture2[orderedCoord].a * _occlusionGain);
        }

        newMixedColor *= 255;
        InterlockedAdd(_sampleBuffer[samplecountIndex].r, uint(newMixedColor.r));
        InterlockedAdd(_sampleBuffer[samplecountIndex].g, uint(newMixedColor.g));
        InterlockedAdd(_sampleBuffer[samplecountIndex].b, uint(newMixedColor.b));
        InterlockedAdd(_sampleBuffer[samplecountIndex].a, uint(newMixedColor.a));
        InterlockedAdd(_sampleCountBuffer[samplecountIndex].x, 1);
	
		// SampleCountBuffer is set to one in the case of visible + empty voxels and will be decayed by the voxel update Compute.
		//InterlockedAdd(SampleCountBuffer[samplecountIndex].y, 1);
    }
}

	