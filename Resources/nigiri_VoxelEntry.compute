#define LUMA_THRESHOLD_FACTOR 0.001f // Higher = higher accuracy with higher flickering
#define LUMA_DEPTH_FACTOR 100.0f 	// Higher = lesser variation with depth
#define LUMA_FACTOR 1.9632107f

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "Nigiri_MortonOrder2D.cginc"
#include "Nigiri_MortonOrder3D.cginc"

uniform RWTexture3D<float4>			voxelGrid;
uniform RWTexture3D<float4>			voxelCasacadeGrid1;
uniform RWTexture3D<float4>			voxelCasacadeGrid2;

RWStructuredBuffer<int>				RenderCounter;
uniform RWStructuredBuffer<uint4>	SampleBuffer	: register(u1);
uniform RWStructuredBuffer<uint>	SampleCountBuffer : register(u2);

cbuffer cbSettings : register(b0)
{
uniform uint					cascade;
	uniform const uint			useDepth;
	uniform const uint			nearestNeighbourPropagation;
	uniform const uint			voxelResolution;
	uniform const float3		gridOffset;
	uniform const float			worldVolumeBoundary;
	uniform const float			occlusionGain;
	uniform const float			emissiveIntensity;
	
	uniform Texture2D<float>			depthTexture;
	uniform Texture2D<float4>			lightingTexture;
	uniform Texture2D<float4>			lightingTexture2;

	uniform Texture2D<float4>			positionTexture;

	uniform const float3 offsets[16] =
	{
		float3(1, 0, 0),
		float3(-1, 0, -0),
		float3(0, 1, 0),
		float3(0, -1, 0),
		float3(0, 0, 1),
		float3(0, 0, -1),
		float3(1, 1, 0),
		float3(1, -1, -0),
		float3(-1, 1, 0),
		float3(-1, -1, -0),
		float3(1, 0, 1),
		float3(1, 0, -1),
		float3(0, 1, 1),
		float3(0, 1, -1),
		float3(0, -1, 1),
		float3(0, -1, -1)
	};
};

uniform float					_shadowStrength;

// Function to get position of voxel in the grid
inline uint4 GetVoxelPosition(float4 worldPosition)
{
	//worldPosition.xyz = worldPosition.xyz - gridOffset.xyz;

	// What do I know?
	// Worldspace position of pixel
	// boundary
	// grid offset
	// depth
	uint cascade = 3;
	float cascade1 = 0.33;
	float cascade2 = 0.66;
	float cascade3 = 1.00;
	uint cachedResolution = voxelResolution;
	int cascadeBoundary = worldVolumeBoundary;
	int cascadeBoundary1 = worldVolumeBoundary * cascade1;
	int cascadeBoundary2 = worldVolumeBoundary * cascade2;
	int cascadeBoundary3 = worldVolumeBoundary * cascade3;

	if ((abs(worldPosition.x) < cascadeBoundary1) && (abs(worldPosition.y) < cascadeBoundary1) && (abs(worldPosition.z) < cascadeBoundary1))
	{
		cascade = 0;
		//cachedResolution = voxelResolution;
		cascadeBoundary = cascadeBoundary1;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary2) && (abs(worldPosition.y) < cascadeBoundary2) && (abs(worldPosition.z) < cascadeBoundary2))
	{
		cascade = 1;
		cachedResolution /= 2;
		cascadeBoundary = cascadeBoundary2;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary3) && (abs(worldPosition.y) < cascadeBoundary3) && (abs(worldPosition.z) < cascadeBoundary3))
	{
		cachedResolution /= 4;
		cascade = 2;
		cascadeBoundary = cascadeBoundary3;
	}
	else cascade = 3;
	
	float3 encodedPosition = worldPosition.xyz / cascadeBoundary;
	   	 
	encodedPosition += float3(1.0f, 1.0f, 1.0f);
	encodedPosition /= 2.0f;

	uint3 voxelPosition = (uint3)(encodedPosition * cachedResolution);

	return float4(voxelPosition.xyz, cascade);
}

uint threeD2oneD(float3 coord)
{
	return coord.z * (voxelResolution * voxelResolution) + (coord.y * voxelResolution) + coord.x;
}

// 0
[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
	uint2 orderedCoord = id.xy;
	uint counter = morton2D_sLUT_Encode(id.x, id.y);

	uint4 voxelPosition = GetVoxelPosition(positionTexture[id.xy]);

	uint samplecountIndex = morton3D_sLUT_Encode(voxelPosition.x, voxelPosition.y, voxelPosition.z);
	
	uint voxelUpdated = 0;
	if ((voxelPosition.w == cascade) && (fmod(counter, 4)))
	{
		voxelUpdated = 1;
		uint index = threeD2oneD(voxelPosition.xyz);
		uint cascadeBoundary0 = voxelResolution * 0.25;
		uint cascadeBoundary1 = voxelResolution * 0.66;
		

		float depth = 0;
		if (useDepth)
		{
			float f = 50.0;
			float n = 0.3;

			depth = (2 * n) / (f + n - depthTexture[id.xy] * (f - n));
			//depth = depthTexture[id.xy];
		}
		else depth = positionTexture[id.xy].a;

		float4 newMixedColor = (0).xxxx;
		if (nearestNeighbourPropagation == 1)
		{
			uint count = 1;
			float4 mixedColor = voxelGrid[voxelPosition.xyz];

			for (int x = 0; x < 16; x++)
			{
				float3 offset = offsets[x];
				half4 testColor = voxelGrid[float3(voxelPosition.xyz + offset.xyz)];
				if (testColor.a > 0.1)
				{
					mixedColor += testColor;
					count++;
				}
			}
			mixedColor /= count;

			newMixedColor =
				float4((max(lightingTexture[id.xy].rgb * emissiveIntensity, lightingTexture2[id.xy].rgb * (1 - _shadowStrength).xxx)),
					lightingTexture2[id.xy].a * occlusionGain);

			newMixedColor = lerp(newMixedColor, mixedColor, 0.5);
		}
		else
		{
			newMixedColor =
				float4((max(lightingTexture[id.xy].rgb * emissiveIntensity, lightingTexture2[id.xy].rgb * (1 - _shadowStrength).xxx)),
					lightingTexture2[id.xy].a * occlusionGain);

			//newMixedColor = lerp(newMixedColor, voxelGrid[voxelPosition.xyz], 0.5);
			//newMixedColor = max(newMixedColor, voxelGrid[voxelPosition.xyz]);
		}

		newMixedColor *= 255;
		InterlockedAdd(SampleBuffer[samplecountIndex].r, uint(newMixedColor.r));
		InterlockedAdd(SampleBuffer[samplecountIndex].g, uint(newMixedColor.g));
		InterlockedAdd(SampleBuffer[samplecountIndex].b, uint(newMixedColor.b));
		InterlockedAdd(SampleBuffer[samplecountIndex].a, uint(newMixedColor.a));
	}

	// SampleCountBuffer is set to one in the case of visible + empty voxels and will be decayed by the voxel update Compute.
	if (voxelUpdated) InterlockedAdd(SampleCountBuffer[samplecountIndex], 2);
	else InterlockedAdd(SampleCountBuffer[samplecountIndex], 1);
}

	