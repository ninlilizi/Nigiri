/// <summary>
/// NKLI     : Nigiri - SVO Node mipmap queue processor
/// Copywrite: Abigail Sara Hocking of Newbury, 2020. 
/// Licence  : The Nigiri 'Bits and pieces' Licence. [v3]
/// </summary>
#pragma kernel CSMain

// Include
#include "NKLI_Nigiri_SVOVoxelizer_Functions.cginc"

// SVO
uniform RWStructuredBuffer<SVONode> _SVO;
// SVO Counters
uniform RWStructuredBuffer<uint> _SVO_Counters;
// SVO Queue of nodes to split
uniform RWStructuredBuffer<uint> _SVO_MipmapQueue;

[numthreads(8, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get queue position
    uint counter;
    InterlockedAdd(_SVO_Counters[4], 1, counter);
    
    // Offset index by one as zero stores append count
    counter++;
    
    // Get index of cell to split
    uint mipmapIndex = _SVO_MipmapQueue[counter];
    
    // If index == 0 then do nothing
    if (mipmapIndex != 0)
    {
        // Decrement by one to get adjusted index
        mipmapIndex--;
        
        // Unpack node to mipmap        
        //SVONode nodeToSplit = _SVO[mipmapIndex];
        //uint bitfieldOccupancy;
        //uint runLength;
        //uint ttl;
        //uint isLeaf;
        //nodeToSplit.UnPackStruct(bitfieldOccupancy, runLength, ttl, isLeaf);
        
        SVONode nodeToMipmap = _SVO[mipmapIndex];
                 
        float4 filteredColour = (0).xxxx;
        
        for (int i = 0; i < 8; i++)
        {
            //filteredColour += _SVO[mipmapIndex + i].UnPackColour();
            filteredColour += _SVO[nodeToMipmap.referenceOffset + i].UnPackColour();
        }
        
       filteredColour /= 8;
        
       filteredColour = float4(1, 1, 1, 1);
        
        nodeToMipmap.PackColour(filteredColour, 0);
        
        _SVO[mipmapIndex] = nodeToMipmap;
        
        //_SVO[mipmapIndex].PackColour(float4(1, 1, 1, 1));

    }

    // Zero value ready for next encode
    _SVO_MipmapQueue[counter] = 0;
}
