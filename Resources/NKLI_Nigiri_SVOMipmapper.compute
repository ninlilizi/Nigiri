/// <summary>
/// NKLI     : Nigiri - SVO Node mipmap queue processor
/// Copywrite: Abigail Sara Hocking of Newbury, 2020. 
/// Licence  : The Nigiri 'Bits and pieces' Licence. [v3]
/// </summary>
#pragma kernel CSMain

// Include
#include "NKLI_Nigiri_SVOVoxelizer_Functions.cginc"

// SVO
uniform RWStructuredBuffer<SVONode> _SVO;
// SVO Counters
uniform RWStructuredBuffer<uint> _SVO_Counters;
// SVO Queue of nodes to split
uniform RWStructuredBuffer<uint> _SVO_MipmapQueue;

// Debug visualisation
uniform const uint _debugFiltering;

// Calculates occupancy bitmap
uint getOccupancyBitmap(uint offset)
{
    return
		(min(_SVO[offset].packedColour, 1) << 7) |
		(min(_SVO[offset + 1].packedColour, 1) << 6) |
		(min(_SVO[offset + 2].packedColour, 1) << 5) |
		(min(_SVO[offset + 3].packedColour, 1) << 4) |
		(min(_SVO[offset + 4].packedColour, 1) << 3) |
		(min(_SVO[offset + 5].packedColour, 1) << 2) |
		(min(_SVO[offset + 6].packedColour, 1) << 1) |
		(min(_SVO[offset + 7].packedColour, 1) & 1);
}

[numthreads(8, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get queue position
    uint counter;
    InterlockedAdd(_SVO_Counters[4], 1, counter);
    
    // Offset index by one as zero stores append count
    counter++;
    
    // Get index of cell to split
    uint mipmapIndex = _SVO_MipmapQueue[counter];
    
    // If index == 0 then do nothing
    if (mipmapIndex)
    {
        // Decrement by one to get adjusted index
        mipmapIndex--;
               
        // Get the target node
        SVONode nodeToMipmap = _SVO[mipmapIndex];
        
        uint _bifFieldOccupancy;
        uint _runLength;
        uint _ttl;
        uint isWaitingForMipmap;
        nodeToMipmap.UnPackStruct(_bifFieldOccupancy, _runLength, _ttl, isWaitingForMipmap);
        _bifFieldOccupancy = getOccupancyBitmap(mipmapIndex);
                 
        // Initialise accumumator
        float4 filteredColour = (0).xxxx;
        
        // Do this for all child nodes
        [unroll]
        for (int i = 0; i < 8; i++)
        {
            // Accumulate samples
            filteredColour += _SVO[nodeToMipmap.referenceOffset + i].UnPackColour();
            
            // Toggle off flag as child nodes are processed
            _SVO[nodeToMipmap.referenceOffset + i].SetIsWaitingForMipmap(0);
        }
        
        // Average sampled nodes
        filteredColour /= 8;
        
        // Debug visualisation
        if (_debugFiltering)
            filteredColour += float4(0.1, 0.1, 0.1, 0);
        
        // Update node properties
        nodeToMipmap.PackStruct(_bifFieldOccupancy, 0, _ttl, 1);
        nodeToMipmap.PackColour(filteredColour);
        //nodeToMipmap.SetIsWaitingForMipmap(1);
        
        // Store node
        _SVO[mipmapIndex] = nodeToMipmap;
    }

    // Zero value ready for next encode
    _SVO_MipmapQueue[counter] = 0;
}
