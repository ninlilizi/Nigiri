// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "NKLI_Nigiri_SVONode.cginc"

// Synchronisation counter buffer
uniform RWStructuredBuffer<uint> buffer_Counters;
// [1] Read counter
// [2] Write SVO counter
// [3] BufferPTR length
// [4] PTR Read counter
// [5] PTR Write counter
// [6] Total threads
// [7] Tree depth
// [8] Depth counter
//
// Input morton buffer
uniform RWStructuredBuffer<uint4> buffer_Morton;
// Temporary PTR storage buffer
uniform RWStructuredBuffer<uint> buffer_PTR;
// Output buffer to contain final SVO
uniform RWStructuredBuffer<SVONode> buffer_SVO;

uint isLeaf = 0;

// Determine if branch or leaf node
void IsLeaf(uint counter)
{
    if (counter < buffer_Counters[buffer_Counters[0]]) isLeaf = 1; // Needs to reference leaf node count only
    else isLeaf = 0;
}

// Calculates occupancy bitmap
uint getOccupancyBitmap(uint counter)
{
	switch (isLeaf)
	{
	case 1:
        // We multiple the counter numeber to account for reading
        //  8 offsets for each write thread
        counter *= 8;
		uint r =
			(min(buffer_Morton[counter].r, 1) << 7) |
			(min(buffer_Morton[counter + 1].r, 1) << 6) |
			(min(buffer_Morton[counter + 2].r, 1) << 5) |
			(min(buffer_Morton[counter + 3].r, 1) << 4) |
			(min(buffer_Morton[counter + 4].r, 1) << 3) |
			(min(buffer_Morton[counter + 5].r, 1) << 2) |
			(min(buffer_Morton[counter + 6].r, 1) << 1) |
			(min(buffer_Morton[counter + 7].r, 1) & 1);
        uint g =
			(min(buffer_Morton[counter].g, 1) << 7) |
			(min(buffer_Morton[counter + 1].g, 1) << 6) |
			(min(buffer_Morton[counter + 2].g, 1) << 5) |
			(min(buffer_Morton[counter + 3].g, 1) << 4) |
			(min(buffer_Morton[counter + 4].g, 1) << 3) |
			(min(buffer_Morton[counter + 5].g, 1) << 2) |
			(min(buffer_Morton[counter + 6].g, 1) << 1) |
			(min(buffer_Morton[counter + 7].g, 1) & 1);
        uint b =
			(min(buffer_Morton[counter].b, 1) << 7) |
			(min(buffer_Morton[counter + 1].b, 1) << 6) |
			(min(buffer_Morton[counter + 2].b, 1) << 5) |
			(min(buffer_Morton[counter + 3].b, 1) << 4) |
			(min(buffer_Morton[counter + 4].b, 1) << 3) |
			(min(buffer_Morton[counter + 5].b, 1) << 2) |
			(min(buffer_Morton[counter + 6].b, 1) << 1) |
			(min(buffer_Morton[counter + 7].b, 1) & 1);
        uint a =
			(min(buffer_Morton[counter].a, 1) << 7) |
			(min(buffer_Morton[counter + 1].a, 1) << 6) |
			(min(buffer_Morton[counter + 2].a, 1) << 5) |
			(min(buffer_Morton[counter + 3].a, 1) << 4) |
			(min(buffer_Morton[counter + 4].a, 1) << 3) |
			(min(buffer_Morton[counter + 5].a, 1) << 2) |
			(min(buffer_Morton[counter + 6].a, 1) << 1) |
			(min(buffer_Morton[counter + 7].a, 1) & 1);
        return (r | g | b | a);  
	case 0:
		return
			(min(buffer_PTR[counter], 1) << 7) |
			(min(buffer_PTR[counter + 1], 1) << 6) |
			(min(buffer_PTR[counter + 2], 1) << 5) |
			(min(buffer_PTR[counter + 3], 1) << 4) |
			(min(buffer_PTR[counter + 4], 1) << 3) |
			(min(buffer_PTR[counter + 5], 1) << 2) |
			(min(buffer_PTR[counter + 6], 1) << 1) |
			(min(buffer_PTR[counter + 7], 1) & 1);
	}
}

// Returns current depth from boundary array
uint GetDepthFromBoundaries(uint index, uint bOffset)
{
    // TODO - Make this efficient (LUT, etc)
    for (uint j = bOffset; j < (buffer_Counters[7] + bOffset); j++)
    {
        if (index < buffer_Counters[j])
            return j - buffer_Counters[0];

    }
    // Return of 999 designates error
    return 999;
}

// Get run length and reference
uint GetFirstReference(uint index)
{
    uint reference;
    //if ((occupancy & (1 << 0)) != 0);
    
    for (uint j = 0; j < 8; j++)
    {
        if (buffer_PTR[index + j] != 0)
        {
            if (reference == 0)
                reference = buffer_PTR[index + j];
            else
                reference = min(reference, buffer_PTR[index + j]);
        }
    }
    return reference;
}

uint GetNumberOfSetBits(uint i)
{
    i = i - ((i >> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
    return (((i + (i >> 4)) & 0x0F0F0F0F) * 0x01010101) >> 24;
}

// Returns length of current depth
uint GetLengthOfDepth(uint depth)
{
    if (depth < buffer_Counters[7])
        return buffer_Counters[depth + buffer_Counters[0] + 1] - buffer_Counters[depth + buffer_Counters[0]];
    else
        return buffer_Counters[6] - buffer_Counters[depth + buffer_Counters[0]];
}


[numthreads(1,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	// Update Unique index
    uint counter_Read;
    InterlockedAdd(buffer_Counters[1], 1, counter_Read);
  
    // Test if leaf node
    IsLeaf(counter_Read);
    
    // Bucket for InterlockExchange operations
    uint exchangeOutput = 0;
    
    uint actualDepth = GetDepthFromBoundaries(counter_Read, buffer_Counters[0]);
    
    // Adjusted counter offset to align 0 with start of ptr buffer
    uint depthOffet = counter_Read - buffer_Counters[actualDepth + buffer_Counters[0]];
    
    
    
    uint occupancyBitmap;
    
    // Output reference to PTR buffer
    uint outputReference = 0;
    

            
    if (isLeaf)
    {
        // Get occupancyBitmap
        occupancyBitmap = getOccupancyBitmap(counter_Read);
        
        // Set reference to Morton  offset
        outputReference = counter_Read;
    }
    else
    {
        // Update PTR ring buffer counter
        uint counter_ReadPTR;
        InterlockedAdd(buffer_Counters[4], 8, counter_ReadPTR);
        
        // Get occupancyBitmap
        occupancyBitmap = getOccupancyBitmap(counter_ReadPTR);
        
        // Set reference to read offset
        outputReference = GetFirstReference(counter_ReadPTR);

        // It end of PTR Buffer reached, then wrap about to the start
        if (counter_ReadPTR >= buffer_Counters[3])
        {
            InterlockedExchange(buffer_Counters[4], 0, exchangeOutput);
        }
    }
     
    if (occupancyBitmap != 0)
    {
        //Get run length
        uint runLength = GetNumberOfSetBits(occupancyBitmap);
        
        SVONode indexedNode;
        indexedNode.Intialize();
        indexedNode.referenceOffset = outputReference;
        
        // Pack data
        indexedNode.PackStruct(occupancyBitmap, runLength, actualDepth, isLeaf);
        
		// Update sparse index
        uint counter_WriteSVO;
        InterlockedAdd(buffer_Counters[2], 1, counter_WriteSVO);

		// Write to sparse buffer
        buffer_SVO[counter_WriteSVO] = indexedNode;
        
        //SVONode exchangeNode;
        //InterlockedExchange(buffer_SVO[counter_WriteSVO], indexedNode, exchangeNode);
        
        // Set reference to output index
        outputReference = counter_WriteSVO;
    }
    else
        outputReference = 0;

    // Update PTR buffer - write
    uint counter_WritePTR;
    InterlockedAdd(buffer_Counters[5], 1, counter_WritePTR);
        
	// Write to PTR buffer  
    InterlockedExchange(buffer_PTR[counter_WritePTR], outputReference, exchangeOutput);


    uint shorfall = 8 - max(GetLengthOfDepth(actualDepth), 8);
    if (shorfall != 0)
    {
        // Update PTR ring buffer
        //InterlockedAdd(buffer_Counters[5], shorfall, counter_WritePTR);
        
        for (uint j = 0; j < shorfall; j++)
        {
		    // Write to PTR buffer
            //buffer_PTR[counter_WritePTR + j] = 0;
        }
    }

    // It end of PTR Buffer reached, then wrap about to the start
    if (counter_WritePTR >= buffer_Counters[3] && fmod(counter_WritePTR, 8))
    {
        InterlockedExchange(buffer_Counters[5], 0, exchangeOutput);
    }
        
    // Depth reached is stored for use by test unit
    if (actualDepth > buffer_Counters[8])
    {
        InterlockedExchange(buffer_Counters[8], actualDepth, exchangeOutput);
    }
}
