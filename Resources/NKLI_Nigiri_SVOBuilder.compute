// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

const uint boundariesOffset = 8;

// Depth of tree
//uniform int buffer_PTR_Length;


/// <summary>
/// Packed octree node data format
/// </summary>
struct SVONode
{
	// Linked reference offset or coordinate
	// (isRoot)  Morton/Buffer, target coordinate/Offset, 32b
	// (!isRoot) This buffer offset, 32b
	uint referenceOffset;

	// Packed payload
	uint packedBitfield;

	// When used in shader, pad to fit 128 bit cache alignment
	//readonly uint pad0;
	//readonly uint pad1;
	// In cases of 64 bit payloads, this is unnecesary

	// Pack 32 bits
	// BO = Bitfield occupancy, 8b
	// RL = Sparse runlength, 4b
	// OD = Octree depth of this node, 4b
	// IR = Is this a root node, 1b
	// Structure [00] [01] [02] [03] [04] [05] [06] [07] [08] [09] [10] [11] [12] [13] [14] [15]
	//            BO   BO   BO   BO   BO   BO   BO   BO   RL   RL   RL   RL   OD   OD   OD   OD
	//           [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] [30] [31]
	//            IR   --   --   --   --   --   --   --   --   --   --   --   --   --   --   --
	void PackStruct(uint bitFieldOccupancy, uint runLength, uint depth, uint isLeaf)
	{
		packedBitfield = (bitFieldOccupancy << 24) | (runLength << 20) | (depth << 16) | (isLeaf << 15);
	}

	// Unpack 32 bits
	void UnPackStruct(out uint _bifFieldOccupancy, out uint _runLength, out uint _depth, out uint isLeaf)
	{
		//ulong padding = (packedBitfield & 0x7FFF);
		isLeaf = (packedBitfield >> 15) & 1;
		_depth = (uint)(packedBitfield >> 16) & 0xF;
		_runLength = (uint)(packedBitfield >> 20) & 0xF;
		_bifFieldOccupancy = (uint)(packedBitfield >> 24) & 0xFF;
	}
};
//

// Synchronisation counter buffer
uniform RWStructuredBuffer<uint> buffer_Counters;
// [0] Read counter
// [1] Write counter
// [2] BufferPTR length
// [3] PTR Read counter
// [4] PTR Write counter
// [5] Total threads
// [6] Tree depth
// [7] Depth counter
//
// Input morton buffer
uniform RWStructuredBuffer<uint4> buffer_Morton;
// Temporary PTR storage buffer
uniform RWStructuredBuffer<uint> buffer_PTR;
// Output buffer to contain final SVO
uniform RWStructuredBuffer<SVONode> buffer_SVO;

uint isLeaf = 0;

// Determine if branch or leaf node
void IsLeaf(uint counter)
{
    if (counter < buffer_Counters[5]) isLeaf = 1;
    else isLeaf = 0;
}

// Calculates occupancy bitmap
uint getOccupancyBitmap(uint counter)
{
	switch (isLeaf)
	{
	case 1:
        counter *= 8;
		uint r =
			(min(buffer_Morton[counter].r, 1) << 7) |
			(min(buffer_Morton[counter + 1].r, 1) << 6) |
			(min(buffer_Morton[counter + 2].r, 1) << 5) |
			(min(buffer_Morton[counter + 3].r, 1) << 4) |
			(min(buffer_Morton[counter + 4].r, 1) << 3) |
			(min(buffer_Morton[counter + 5].r, 1) << 2) |
			(min(buffer_Morton[counter + 6].r, 1) << 1) |
			(min(buffer_Morton[counter + 7].r, 1) & 1);
        uint g =
			(min(buffer_Morton[counter].g, 1) << 7) |
			(min(buffer_Morton[counter + 1].g, 1) << 6) |
			(min(buffer_Morton[counter + 2].g, 1) << 5) |
			(min(buffer_Morton[counter + 3].g, 1) << 4) |
			(min(buffer_Morton[counter + 4].g, 1) << 3) |
			(min(buffer_Morton[counter + 5].g, 1) << 2) |
			(min(buffer_Morton[counter + 6].g, 1) << 1) |
			(min(buffer_Morton[counter + 7].g, 1) & 1);
        uint b =
			(min(buffer_Morton[counter].b, 1) << 7) |
			(min(buffer_Morton[counter + 1].b, 1) << 6) |
			(min(buffer_Morton[counter + 2].b, 1) << 5) |
			(min(buffer_Morton[counter + 3].b, 1) << 4) |
			(min(buffer_Morton[counter + 4].b, 1) << 3) |
			(min(buffer_Morton[counter + 5].b, 1) << 2) |
			(min(buffer_Morton[counter + 6].b, 1) << 1) |
			(min(buffer_Morton[counter + 7].b, 1) & 1);
        uint a =
			(min(buffer_Morton[counter].a, 1) << 7) |
			(min(buffer_Morton[counter + 1].a, 1) << 6) |
			(min(buffer_Morton[counter + 2].a, 1) << 5) |
			(min(buffer_Morton[counter + 3].a, 1) << 4) |
			(min(buffer_Morton[counter + 4].a, 1) << 3) |
			(min(buffer_Morton[counter + 5].a, 1) << 2) |
			(min(buffer_Morton[counter + 6].a, 1) << 1) |
			(min(buffer_Morton[counter + 7].a, 1) & 1);
        return (r | g | b | a);  
	case 0:
		return
			(min(buffer_PTR[counter], 1) << 7) |
			(min(buffer_PTR[counter + 1], 1) << 6) |
			(min(buffer_PTR[counter + 2], 1) << 5) |
			(min(buffer_PTR[counter + 3], 1) << 4) |
			(min(buffer_PTR[counter + 4], 1) << 3) |
			(min(buffer_PTR[counter + 5], 1) << 2) |
			(min(buffer_PTR[counter + 6], 1) << 1) |
			(min(buffer_PTR[counter + 7], 1) & 1);
	}
}

// Returns current depth from boundary array
uint GetDepthFromBoundaries(uint index)
{
	// TODO - Make this efficient (LUT, etc)
	
    for (uint j = boundariesOffset; j < (buffer_Counters[6] + boundariesOffset); j++)
    {
        if (index < buffer_Counters[j])
            return j - boundariesOffset;

    }
    // Return of 999 designates error
    return 999;
}

// Returns length of current depth
uint GetLengthOfDepth(uint depth)
{
    if (depth < buffer_Counters[6])
        return buffer_Counters[depth + boundariesOffset + 1] - buffer_Counters[depth + boundariesOffset];
    else
        return buffer_Counters[5] - buffer_Counters[depth + boundariesOffset];
}


[numthreads(1,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	// Update Unique index
	uint counter_Read;
    InterlockedAdd(buffer_Counters[0], 1, counter_Read);
  
    // Test if leaf node
    IsLeaf(counter_Read);
    
    uint actualDepth = GetDepthFromBoundaries(counter_Read);
    uint occupancyBitmap;
    uint counter_WritePTR;
    
    // Pack SVONode data depending on node type
    SVONode indexedNode;
    if (isLeaf)
    {
        // Get occupancyBitmap
        occupancyBitmap = getOccupancyBitmap(counter_Read);
        
        // Set reference offset
        indexedNode.referenceOffset = counter_Read;
    }
    else
    {       
        // Update PTR ring buffer counter
        uint counter_ReadPTR;
        InterlockedAdd(buffer_Counters[3], 8, counter_ReadPTR);
        
        // Get occupancyBitmap
        occupancyBitmap = getOccupancyBitmap(counter_ReadPTR);
        
        // Set reference offset
        indexedNode.referenceOffset = counter_ReadPTR;
        
        // It end of PTR Buffer reached, then wrap about to the start
        if (counter_ReadPTR >= buffer_Counters[2])
        {
            uint exchange;
            InterlockedExchange(buffer_Counters[3], 0, exchange);
        }
    }
    indexedNode.PackStruct(occupancyBitmap, 0, actualDepth, isLeaf);

    if (occupancyBitmap != 0)
    {
		// Update sparse index
        uint counter_Write;
        InterlockedAdd(buffer_Counters[1], 1, counter_Write);

		// Write to sparse buffer
        buffer_SVO[counter_Write] = indexedNode;
        
        // Update PTR ring buffer
        InterlockedAdd(buffer_Counters[4], 1, counter_WritePTR);
        
        // Write to PTR buffer
        buffer_PTR[counter_WritePTR] = counter_Read;
    }
    else
    {
        // Update PTR ring buffer
        InterlockedAdd(buffer_Counters[4], 1, counter_WritePTR);
        
		// Write to PTR buffer
        buffer_PTR[counter_WritePTR] = 0;
        
    }

    // It end of PTR Buffer reached, then wrap about to the start
    if (counter_WritePTR >= buffer_Counters[2])
    {
        uint exchange = 0;
        InterlockedExchange(buffer_Counters[4], 0, exchange);
    }
        
    //if (actualDepth > buffer_Counters[7])
    //{
    if (actualDepth != 0)
    {
        uint exchange;
        InterlockedExchange(buffer_Counters[7], actualDepth, exchange);
    }
	// Incrment depth counter if boundary index
    //if (buffer_Counters[2] < treeDepth)
    //{
    //if ((int) counter_Read == (int) boundaries[buffer_Counters[2]])
    //{
    //    InterlockedAdd(buffer_Counters[2], 1);
    //}
    //}
    }
