// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWTexture2D<float4> Result;

// Depth of tree
uniform int treeDepth;
// Array of depth boundaries
uniform int boundaries[32];


/// <summary>
/// Packed octree node data format
/// </summary>
struct SVONode
{
	// Linked reference offset or coordinate
	// (isRoot)  Morton/Buffer, target coordinate/Offset, 32b
	// (!isRoot) This buffer offset, 32b
	uint referenceOffset;

	// Packed payload
	uint packedBitfield;

	// When used in shader, pad to fit 128 bit cache alignment
	//readonly uint pad0;
	//readonly uint pad1;
	// In cases of 64 bit payloads, this is unnecesary

	// Constructor - Packed
	void SVONode(uint _referenceOffset, uint _packedBitfield)
	{
		packedBitfield = _packedBitfield;
		referenceOffset = _referenceOffset;
	}

	// Constructor - UnPacked
	void SVONode(uint _referenceOffset, uint bitFieldOccupancy, uint runLength, uint depth, bool isRoot)
	{
		packedBitfield = 0;
		referenceOffset = _referenceOffset;
		PackStruct(bitFieldOccupancy, runLength, depth, isRoot);
	}

	// Pack 32 bits
	// BO = Bitfield occupancy, 8b
	// RL = Sparse runlength, 4b
	// OD = Octree depth of this node, 4b
	// IR = Is this a root node, 1b
	// Structure [00] [01] [02] [03] [04] [05] [06] [07] [08] [09] [10] [11] [12] [13] [14] [15]
	//            BO   BO   BO   BO   BO   BO   BO   BO   RL   RL   RL   RL   OD   OD   OD   OD
	//           [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] [30] [31]
	//            IR   --   --   --   --   --   --   --   --   --   --   --   --   --   --   --
	void PackStruct(uint bitFieldOccupancy, uint runLength, uint depth, uint isRoot)
	{
		packedBitfield = (bitFieldOccupancy << 32) | (runLength << 24) | (depth << 20) | (isRoot << 16);
	}

	// Unpack 32 bits
	void UnPackStruct(out uint _bifFieldOccupancy, out uint _runLength, out uint _depth, out uint isRoot)
	{
		//ulong padding = (packedBitfield & 0x7FFF);
		isRoot = (packedBitfield >> 15) & 1;
		_depth = (uint)(packedBitfield >> 16) & 0xF;
		_runLength = (uint)(packedBitfield >> 20) & 0xF;
		_bifFieldOccupancy = (uint)(packedBitfield >> 24) & 0xFF;
	}
};
//

// Synchronisation counter buffer
uniform RWStructuredBuffer<uint>	buffer_Counters;
// [0] Read counter
// [1] Write counter

// Temporary PTR storage buffer
uniform RWStructuredBuffer<uint4>	buffer_Morton;

// Temporary PTR storage buffer
uniform RWStructuredBuffer<uint>	buffer_PTR;
// Output buffer to contain final SVO
uniform RWStructuredBuffer<SVONode>	buffer_SVO;

// Determine if branch or leaf node
uint isLeaf(uint counter)
{
	if ((uint)boundaries[0] < counter) return 1;
	else return 0;
}

// Calculates occupancy bitmap
uint getOccupancyBitmap(uint counter)
{
	switch (isLeaf(counter))
	{
	case 1:
		return
			(min(buffer_Morton[counter], 1) << 7) |
			(min(buffer_Morton[counter + 1], 1) << 6) |
			(min(buffer_Morton[counter + 2], 1) << 5) |
			(min(buffer_Morton[counter + 3], 1) << 4) |
			(min(buffer_Morton[counter + 4], 1) << 3) |
			(min(buffer_Morton[counter + 5], 1) << 2) |
			(min(buffer_Morton[counter + 6], 1) << 1) |
			(min(buffer_Morton[counter + 7], 1));
	case 0:
		return
			(min(buffer_PTR[counter], 1) << 7) |
			(min(buffer_PTR[counter + 1], 1) << 6) |
			(min(buffer_PTR[counter + 2], 1) << 5) |
			(min(buffer_PTR[counter + 3], 1) << 4) |
			(min(buffer_PTR[counter + 4], 1) << 3) |
			(min(buffer_PTR[counter + 5], 1) << 2) |
			(min(buffer_PTR[counter + 6], 1) << 1) |
			(min(buffer_PTR[counter + 7], 1));
	}
}


[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	// Update Unique index
	uint counter_Read;
	InterlockedAdd(buffer_Counters[0], 1, counter_Read);

	uint occupancyBitmap = getOccupancyBitmap(counter_Read);

	//uint a = table[uint(clamp(b, 0, treeDepth) / 2)];

	SVONode indexedNode;
	//indexNode.PackStruct(occupancyBitmap, 0, )

	if (occupancyBitmap != 0)
	{
		buffer_PTR[counter_Read] = counter_Read;

		// Update Unique index
		uint counter_Write;
		InterlockedAdd(buffer_Counters[1], 1, counter_Write);
	}
	else
	{
		buffer_PTR[counter_Read] = 0;
	}

	SVONode derp = buffer_SVO[0];
	derp.SVONode(0, 0);

	//buffer_SVO[0].PackStruct(0, 0, 0, 0);
}
