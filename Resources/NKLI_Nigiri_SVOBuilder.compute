// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Depth of tree
uniform int treeDepth;
// Array of depth boundaries
uniform int boundaries[64];


/// <summary>
/// Packed octree node data format
/// </summary>
struct SVONode
{
	// Linked reference offset or coordinate
	// (isRoot)  Morton/Buffer, target coordinate/Offset, 32b
	// (!isRoot) This buffer offset, 32b
	uint referenceOffset;

	// Packed payload
	uint packedBitfield;

	// When used in shader, pad to fit 128 bit cache alignment
	//readonly uint pad0;
	//readonly uint pad1;
	// In cases of 64 bit payloads, this is unnecesary

	// Pack 32 bits
	// BO = Bitfield occupancy, 8b
	// RL = Sparse runlength, 4b
	// OD = Octree depth of this node, 4b
	// IR = Is this a root node, 1b
	// Structure [00] [01] [02] [03] [04] [05] [06] [07] [08] [09] [10] [11] [12] [13] [14] [15]
	//            BO   BO   BO   BO   BO   BO   BO   BO   RL   RL   RL   RL   OD   OD   OD   OD
	//           [16] [17] [18] [19] [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] [30] [31]
	//            IR   --   --   --   --   --   --   --   --   --   --   --   --   --   --   --
	void PackStruct(uint bitFieldOccupancy, uint runLength, uint depth, uint isLeaf)
	{
		packedBitfield = (bitFieldOccupancy << 24) | (runLength << 20) | (depth << 16) | (isLeaf << 15);
	}

	// Unpack 32 bits
	void UnPackStruct(out uint _bifFieldOccupancy, out uint _runLength, out uint _depth, out uint isLeaf)
	{
		//ulong padding = (packedBitfield & 0x7FFF);
		isLeaf = (packedBitfield >> 15) & 1;
		_depth = (uint)(packedBitfield >> 16) & 0xF;
		_runLength = (uint)(packedBitfield >> 20) & 0xF;
		_bifFieldOccupancy = (uint)(packedBitfield >> 24) & 0xFF;
	}
};
//

// Synchronisation counter buffer
uniform RWStructuredBuffer<uint> buffer_Counters;
// [0] Read counter
// [1] Write counter
// [2] Depth counter
//
// Input morton buffer
uniform RWStructuredBuffer<uint4> buffer_Morton;
// Temporary PTR storage buffer
uniform RWStructuredBuffer<uint> buffer_PTR;
// Output buffer to contain final SVO
uniform RWStructuredBuffer<SVONode> buffer_SVO;

uint isLeaf = 0;

// Determine if branch or leaf node
void IsLeaf(uint counter)
{
    if (counter < (uint)boundaries[0]) isLeaf = 1;
    else isLeaf = 0;
}

// Calculates occupancy bitmap
uint getOccupancyBitmap(uint counter)
{
	switch (isLeaf)
	{
	case 1:
        counter *= 8;
		uint r =
			(min(buffer_Morton[counter].r, 1) << 7) |
			(min(buffer_Morton[counter + 1].r, 1) << 6) |
			(min(buffer_Morton[counter + 2].r, 1) << 5) |
			(min(buffer_Morton[counter + 3].r, 1) << 4) |
			(min(buffer_Morton[counter + 4].r, 1) << 3) |
			(min(buffer_Morton[counter + 5].r, 1) << 2) |
			(min(buffer_Morton[counter + 6].r, 1) << 1) |
			(min(buffer_Morton[counter + 7].r, 1) & 1);
        uint g =
			(min(buffer_Morton[counter].g, 1) << 7) |
			(min(buffer_Morton[counter + 1].g, 1) << 6) |
			(min(buffer_Morton[counter + 2].g, 1) << 5) |
			(min(buffer_Morton[counter + 3].g, 1) << 4) |
			(min(buffer_Morton[counter + 4].g, 1) << 3) |
			(min(buffer_Morton[counter + 5].g, 1) << 2) |
			(min(buffer_Morton[counter + 6].g, 1) << 1) |
			(min(buffer_Morton[counter + 7].g, 1) & 1);
        uint b =
			(min(buffer_Morton[counter].b, 1) << 7) |
			(min(buffer_Morton[counter + 1].b, 1) << 6) |
			(min(buffer_Morton[counter + 2].b, 1) << 5) |
			(min(buffer_Morton[counter + 3].b, 1) << 4) |
			(min(buffer_Morton[counter + 4].b, 1) << 3) |
			(min(buffer_Morton[counter + 5].b, 1) << 2) |
			(min(buffer_Morton[counter + 6].b, 1) << 1) |
			(min(buffer_Morton[counter + 7].b, 1) & 1);
        uint a =
			(min(buffer_Morton[counter].a, 1) << 7) |
			(min(buffer_Morton[counter + 1].a, 1) << 6) |
			(min(buffer_Morton[counter + 2].a, 1) << 5) |
			(min(buffer_Morton[counter + 3].a, 1) << 4) |
			(min(buffer_Morton[counter + 4].a, 1) << 3) |
			(min(buffer_Morton[counter + 5].a, 1) << 2) |
			(min(buffer_Morton[counter + 6].a, 1) << 1) |
			(min(buffer_Morton[counter + 7].a, 1) & 1);
        return (r | g | b | a);  
	case 0:
		return
			(min(buffer_PTR[counter], 1) << 7) |
			(min(buffer_PTR[counter + 1], 1) << 6) |
			(min(buffer_PTR[counter + 2], 1) << 5) |
			(min(buffer_PTR[counter + 3], 1) << 4) |
			(min(buffer_PTR[counter + 4], 1) << 3) |
			(min(buffer_PTR[counter + 5], 1) << 2) |
			(min(buffer_PTR[counter + 6], 1) << 1) |
			(min(buffer_PTR[counter + 7], 1) & 1);
	}
}

// Finds current depth from boundary array
uint GetDepthFromBoundaries(uint index)
{
	// TODO - Make this efficient (LUT, etc)
	return 0;
}



[numthreads(1,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	// Update Unique index
	uint counter_Read = 1;
    InterlockedAdd(buffer_Counters[0], 1, counter_Read);
  
    // Test if leaf node
    IsLeaf(counter_Read);

    // Get occupancyBitmap
	uint occupancyBitmap = getOccupancyBitmap(counter_Read);

	if (occupancyBitmap != 0)
	{
		// Write to PTR buffer
		buffer_PTR[counter_Read] = counter_Read;

		// Pack SVO node data
        SVONode indexedNode;
        indexedNode.referenceOffset = counter_Read;
        indexedNode.PackStruct(occupancyBitmap, 0, buffer_Counters[2], isLeaf);

		// Update sparse index
		uint counter_Write;
        InterlockedAdd(buffer_Counters[1], 1, counter_Write);

		// Write to sparse buffer
        buffer_SVO[counter_Write] = indexedNode;
    }
	else
	{
		// Write to PTR buffer
		//buffer_PTR[counter_Read] = 0;
	}

	// Incrment depth counter if boundary index
    //if (buffer_Counters[2] < treeDepth)
    //{
    if (counter_Read == (int)boundaries[buffer_Counters[2]])
    {
        InterlockedAdd(buffer_Counters[2], 1);
    }
    //}
}
