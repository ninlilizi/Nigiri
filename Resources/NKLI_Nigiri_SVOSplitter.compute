/// <summary>
/// NKLI     : Nigiri - SVO Node split queue processor
/// Copywrite: Abigail Sara Hocking of Newbury, 2020. 
/// Licence  : The Nigiri 'Bits and pieces' Licence. [v3]
/// </summary>
#pragma kernel CSMain

// Include
#include "NKLI_Nigiri_SVOVoxelizer_Functions.cginc"

// SVO
uniform RWStructuredBuffer<SVONode> _SVO;
// SVO Counters
uniform RWStructuredBuffer<uint> _SVO_Counters;
// SVO Internal Counters
uniform RWStructuredBuffer<uint> _SVO_Counters_Internal;
// SVO Queue of nodes to split
uniform RWStructuredBuffer<uint> _SVO_SplitQueue;

// Max SVO depth
uniform const uint _SVO_MaxNodes;

[numthreads(8, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
    uint counter;
    // Get queue position
    InterlockedAdd(_SVO_Counters[2], 1, counter);
      
    if (counter < _SVO_SplitQueue[0])
    {
        // Offset index by one as zero stores append count
        counter++;

        // Get index of cell to split
        uint splitIndex = _SVO_SplitQueue[counter];
    
        // If index == 0 then do nothing
        if (splitIndex)
        {
            // Decrement by one to get adjusted index
            splitIndex--;
        
            // Unpack node to be split        
            SVONode nodeToSplit = _SVO[splitIndex];
            uint bitfieldOccupancy;
            uint ttl;
            uint isLeaf;
            nodeToSplit.UnPackStruct(bitfieldOccupancy, ttl, isLeaf);
        
            // Only split the node if TTL is non-zero, reference is null and SVO not full
            if ((ttl) && (!nodeToSplit.referenceOffset) && (_SVO_Counters_Internal[0] < _SVO_MaxNodes))
            {
        
                // pack node to write        
                SVONode nodeToWrite;
                nodeToWrite.Intialize();
                nodeToWrite.PackStruct(0, (ttl - 1), 0);
            
                // Get write position
                uint writePosition;
                InterlockedAdd(_SVO_Counters_Internal[0], 8, writePosition);
            
                // write new nodes
                _SVO[writePosition] = nodeToWrite;
                _SVO[writePosition + 1] = nodeToWrite;
                _SVO[writePosition + 2] = nodeToWrite;
                _SVO[writePosition + 3] = nodeToWrite;
                _SVO[writePosition + 4] = nodeToWrite;
                _SVO[writePosition + 5] = nodeToWrite;
                _SVO[writePosition + 6] = nodeToWrite;
                _SVO[writePosition + 7] = nodeToWrite;
            
                // Update split node
                nodeToSplit.referenceOffset = writePosition;
                _SVO[splitIndex] = nodeToSplit;
            }
        
            // Zero value ready for next encode
            _SVO_SplitQueue[counter] = 0;
            
            // We're done here.
            return;
        }
        
        // Zero value ready for next encode
        _SVO_SplitQueue[counter] = 0;
    }
    
    // If we don't have any work left, then use remaining
    // threads of the wave to just zero counter.
    _SVO_SplitQueue[0] = 0;
}