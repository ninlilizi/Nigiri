// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "NKLI_Nigiri_MortonOrder2D.cginc"

// Unique Index for computing access coordinates
uniform RWStructuredBuffer<uint>	_renderCountBuffer;
// Output to voxelisation queue
uniform AppendStructuredBuffer<uint>	_maskBuffer	 : register(u1);

cbuffer cbSettings : register(b0)
{
	uniform const uint				MaskIndex;
	uniform const uint				CountIndex;

	uniform const uint					_cascade;
	uniform const float				_giAreaSize;

	uniform Texture2D<float4>		positionTexture;
};

inline uint twoD2oneD(uint x, uint y, uint width)
{
	return x + (y * width);
}

inline uint2 oneD2twoD(uint index, uint width)
{
	return uint2(index % width, index / width);
}

// Function to get position of voxel in the grid
inline uint GetVoxelCascade(float4 worldPosition)
{
	int cascadeBoundary = _giAreaSize;
	int cascadeBoundary1 = _giAreaSize * 0.33;
	int cascadeBoundary2 = _giAreaSize * 0.66;
	int cascadeBoundary3 = _giAreaSize * 1.00;

	if ((abs(worldPosition.x) < cascadeBoundary1) && (abs(worldPosition.y) < cascadeBoundary1) && (abs(worldPosition.z) < cascadeBoundary1))
	{
		return 0;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary2) && (abs(worldPosition.y) < cascadeBoundary2) && (abs(worldPosition.z) < cascadeBoundary2))
	{
		return 1;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary3) && (abs(worldPosition.y) < cascadeBoundary3) && (abs(worldPosition.z) < cascadeBoundary3))
	{
		return 2;
	}
	else return 3;
}

// 0
[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
	// Update Unique index
	uint counter;
	InterlockedAdd(_renderCountBuffer[MaskIndex], 1, counter);
	uint2 orderedCoord = morton2D_MagicBits_Decode(counter);


	if ((GetVoxelCascade(positionTexture[orderedCoord]) == _cascade) && (fmod(counter, 2) == 0))
	{
		InterlockedAdd(_renderCountBuffer[CountIndex], 1);
		_maskBuffer.Append(counter);
		
	}
	/*else
	{
		//DecayCount.IncrementCounter();
	}*/
}

	