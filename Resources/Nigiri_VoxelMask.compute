// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "Nigiri_MortonOrder2D.cginc"

//uniform RWTexture2D<half>				voxelMask	 : register(u1);
uniform AppendStructuredBuffer<uint2>	MaskBuffer	 : register(u1);
RWStructuredBuffer<uint>				DecayCount;
RWStructuredBuffer<uint>				MaskCount;


cbuffer cbSettings : register(b0)
{
	uniform uint					cascade;
	uniform const uint				voxelResolution;
	uniform const float3			gridOffset;
	uniform const float				worldVolumeBoundary;

	uniform Texture2D<float4>		positionTexture;
};

// Function to get position of voxel in the grid
inline uint GetVoxelCascade(float4 worldPosition)
{
	int cascadeBoundary = worldVolumeBoundary;
	int cascadeBoundary1 = worldVolumeBoundary * 0.33;
	int cascadeBoundary2 = worldVolumeBoundary * 0.66;
	int cascadeBoundary3 = worldVolumeBoundary * 1.00;

	if ((abs(worldPosition.x) < cascadeBoundary1) && (abs(worldPosition.y) < cascadeBoundary1) && (abs(worldPosition.z) < cascadeBoundary1))
	{
		return 0;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary2) && (abs(worldPosition.y) < cascadeBoundary2) && (abs(worldPosition.z) < cascadeBoundary2))
	{
		return 1;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary3) && (abs(worldPosition.y) < cascadeBoundary3) && (abs(worldPosition.z) < cascadeBoundary3))
	{
		return 2;
	}
	else return 3;
}

// 0
[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
	uint2 orderedCoord = id.xy;
	uint counter = morton2D_sLUT_Encode(id.x, id.y);

	if ((GetVoxelCascade(positionTexture[id.xy]) == cascade) && (fmod(counter, 1) == 0))
	{
		MaskCount.IncrementCounter();
		MaskBuffer.Append(id.xy);
		
	}
	else
	{
		DecayCount.IncrementCounter();
	}
}

	