// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "Nigiri_MortonOrder2D.cginc"

//uniform RWTexture2D<half>				voxelMask	 : register(u1);
uniform AppendStructuredBuffer<uint2>	_maskBuffer	 : register(u1);
//RWStructuredBuffer<uint>				DecayCount;
RWStructuredBuffer<uint>				_renderCountBuffer;


cbuffer cbSettings : register(b0)
{
	uniform const uint				CountIndex;

	uniform const uint					_cascade;
	//uniform const uint			_voxelResolution;
	//uniform const float3			gridOffset;
	uniform const float				_giAreaSize;

	uniform Texture2D<float4>		positionTexture;
};

// Function to get position of voxel in the grid
inline uint GetVoxelCascade(float4 worldPosition)
{
	int cascadeBoundary = _giAreaSize;
	int cascadeBoundary1 = _giAreaSize * 0.33;
	int cascadeBoundary2 = _giAreaSize * 0.66;
	int cascadeBoundary3 = _giAreaSize * 1.00;

	if ((abs(worldPosition.x) < cascadeBoundary1) && (abs(worldPosition.y) < cascadeBoundary1) && (abs(worldPosition.z) < cascadeBoundary1))
	{
		return 0;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary2) && (abs(worldPosition.y) < cascadeBoundary2) && (abs(worldPosition.z) < cascadeBoundary2))
	{
		return 1;
	}
	else if ((abs(worldPosition.x) < cascadeBoundary3) && (abs(worldPosition.y) < cascadeBoundary3) && (abs(worldPosition.z) < cascadeBoundary3))
	{
		return 2;
	}
	else return 3;
}

// 0
[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID, uint thread : SV_GroupIndex)
{
	uint2 orderedCoord = id.xy;
	uint counter = morton2D_sLUT_Encode(id.x, id.y);

	if ((GetVoxelCascade(positionTexture[id.xy]) == _cascade) && (fmod(counter, 1) == 0))
	{
		InterlockedAdd(_renderCountBuffer[CountIndex], 1);
		//MaskCount.IncrementCounter();
		_maskBuffer.Append(id.xy);
		
	}
	else
	{
		//DecayCount.IncrementCounter();
	}
}

	